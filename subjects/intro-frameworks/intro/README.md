# Введение во фреймворки

## Краткая история

JS был создан в 1996 году и добавил интерактивность в веб, который до этого состоял из статических страниц.
С тех пор JS стал неотемлемой частью интернета, его популярность росла. На сегодняшний день он используется в [95% всех веб-сайтов](https://w3techs.com/technologies/details/cp-javascript).

Разработчики JS сталкивались с проблемами и писали для них решения, упаковывая их в библиотеки, чтобы ими можно было делиться с другими.

Появление современных фреймворков JavaScript значительно упростило создание высокодинамичных интерактивных приложений. **Фреймворк** — это библиотека, которая предлагает решения по созданию программного обеспечения. Эти решения обеспечивают предсказуемость и однородность приложения; предсказуемость позволяет приложению масштабироваться, при этом оставаясь легко поддерживаемым. Эти критерии являются необходимыми для работоспособности и долговечности.

Фреймворки JavaScript поддерживают большую часть ПО в современной сети, включая многие веб-сайты, которые вы, вероятно, используете каждый день.

## Какие фреймворки существуют?

### Ember

Изначально [**Ember**](https://emberjs.com/) был выпущен в декабре 2011 года как продолжение работы, начатой ​​в проекте SproutCore . Это более старый фреймворк, у которого меньше пользователей, чем у более современных альтернатив, таких как **React** и **Vue**, но он по-прежнему пользуется значительной популярностью благодаря своей стабильности, поддержке сообщества и некоторым умным принципам программирования.

### Angular

[**Angular**](https://angular.io/) — это фреймворк с открытым исходным кодом, возглавляемый командой Angular в Google и сообществом отдельных лиц и корпораций. Это полностью переработанная версия **AngularJS**. **Angular** был официально выпущен 14 сентября 2016 года.

Angular — это фреймворк на основе компонентов, использующий декларативные HTML-шаблоны. Во время сборки, прозрачно для разработчиков, компилятор фреймворка транслирует шаблоны в оптимизированные инструкции **JavaScript**. Angular использует **TypeScript**.

### Vue

После работы и изучения оригинального проекта [**AngularJS**](https://angularjs.org/) Эван Ю выпустил [**Vue**](https://vuejs.org/) в 2014 году. **Vue** — самый молодой из большой четверки, но в последнее время его популярность резко возросла.

**Vue**, как и **AngularJS** , расширяет HTML с помощью собственного кода. Кроме того, он в основном опирается на современный стандартный **JavaScript**.

### React

Facebook выпустил [**React**](https://reactjs.org/) в 2013 году. К этому моменту он уже использовал React для решения многих своих внутренних задач. Технически, React сам по себе не является фреймворком; это библиотека для рендеринга компонентов пользовательского интерфейса. **React** используется в сочетании с другими библиотеками для создания приложений — **React** и **React Native** позволяют разработчикам создавать мобильные приложения; **React** и **ReactDOM** позволяют им создавать веб-приложения и т.д.

**React** расширяет **JavaScript** с помощью HTML-подобного синтаксиса, известного как **JSX** .

## Зачем существуют фреймворки?

Представим приложение todo app, которое вы делали в начале данного курса. Это приложение должно позволять пользователям выполнять такие действия, как отображение списка задач, добавление новой задачи и удаление задачи. Это должно происходить надежно отслеживая и обновляя данные, лежащие в основе приложения. В разработке программного обеспечения эти базовые данные известны как **состояние**.

Каждая из наших целей теоретически проста сама по себе. Мы можем перебирать данные, чтобы отобразить их; мы можем добавить к объекту новую задачу; мы можем использовать идентификатор для поиска, редактирования или удаления задачи. Когда мы вспоминаем, что приложение должно позволять пользователю делать все эти вещи через браузер, начинают проявляться некоторые трещины. Настоящая проблема заключается в следующем: **каждый раз, когда мы меняем состояние нашего приложения, нам нужно обновлять пользовательский интерфейс**.

## Изменения DOM-дерева

Для создания HTML-элементов и их рендеринга в браузере в нужное время требуется много кода. Предположим, что наше состояние представляет собой массив объектов, структурированный следующим образом:

```jsx
const state = [
  {
    id: "todo-0",
    name: "Learn some frameworks!",
  },
];
```

Как мы покажем одну из этих задач нашему пользователю? Мы хотим представить каждую задачу как элемент списка — `<li>`элемент HTML внутри элемента неупорядоченного списка (a `<ul>`).

```jsx
function buildTodoItemEl(id, name) {
  const item = document.createElement("li");
  const span = document.createElement("span");
  const textContent = document.createTextNode(name);

  span.appendChild(textContent);

  item.id = id;
  item.appendChild(span);
  item.appendChild(buildDeleteButtonEl(id));

  return item;
}
```

Здесь мы используем `document.createElement()` метод для создания нашего `<li>`, и еще несколько строк кода для создания необходимых свойств и дочерних элементов.

Десятая строка предыдущего фрагмента ссылается на другую функцию сборки: `buildDeleteButtonEl()`:

```jsx
function buildDeleteButtonEl(id) {
  const button = document.createElement("button");
  const textContent = document.createTextNode("Delete");

  button.setAttribute("type", "button");
  button.appendChild(textContent);

  return button;
}
```

Эта кнопка пока ничего не делает, но она будет позже, когда мы решим реализовать нашу функцию удаления. Код, который будет отображать наши элементы на странице, может выглядеть примерно так:

```jsx
function renderTodoList() {
  const frag = document.createDocumentFragment();
  state.tasks.forEach((task) => {
    const item = buildTodoItemEl(task.id, task.name);
    frag.appendChild(item);
  });

  while (todoListEl.firstChild) {
    todoListEl.removeChild(todoListEl.firstChild);
  }
  todoListEl.appendChild(frag);
}
```

Теперь у нас есть более тридцати строк кода, предназначенных только для пользовательского интерфейса — просто для отображения чего-либо в DOM — и мы ни в коем случае не добавляем классы, которые мы могли бы использовать позже для стилизации наших элементов списка.

Работа напрямую с DOM требует понимания многих аспектов.

Фреймворки JavaScript были созданы, чтобы сделать такую ​​работу намного проще. Они не привносят в JavaScript совершенно новых возможностей, но дают более легкий доступ к его возможностям.

## Пример рендеринга во `Vue`

Каждая среда JavaScript предлагает способ написания пользовательских интерфейсов более декларативно. То есть они позволяют описывать интерфейс, а фреймворк обновляет и рендерит DOM "за кулисами".

Подход обычного JavaScript к построению новых элементов DOM трудно понять с первого взгляда. Напротив, следующий блок кода иллюстрирует, как вы можете использовать **Vue** для описания нашего списка задач:

```jsx
<ul>
  <li v-for="task in tasks" v-bind:key="task.id">
    <span>{{task.name}}</span>
    <button type="button">Delete</button>
  </li>
</ul>

```

Благодаря Vue нам не пришлось писать собственные функции для создания пользовательского интерфейса; фреймворк справится с этим оптимизированным и эффективным способом. Использование фреймворка повышает как командную, так и индивидуальную эффективность.

Подобные вещи можно делать и в ванильном JavaScript. [Литеральные строки шаблона](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) упрощают написание строк `HTML`. Это может быть полезно для чего-то простого, как наше приложение списка дел, но оно непригодно для сопровождения больших приложений, которые управляют тысячами записей пользователей и могут отображать столько же уникальных элементов в пользовательском интерфейсе.
