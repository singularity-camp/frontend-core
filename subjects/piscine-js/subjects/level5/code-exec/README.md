# Выполнение асинхронных функций

Из уроков по Java вы уже изучили понятие стек вызовов. Это нам пригодится, чтобы разобраться как работает асинхронный JS код.

### Стек вызовов

В стеке вызовов хранятся функции, до которых дошёл интерпретатор, и которые надо выполнить.

```jsx
function outer() {
  function inner() {
    // Функция 3
    console.log("Hello!");
  }

  // Функция 2
  inner();
}

// Функция 1
outer();
```

1. Вызываем функцию 1 - `outer()`, она попадает в стек.
2. Вызываем функцию 2 - `inner()`, теперь в стеке 2 функции, потому что первая ещё не выполнилась до конца.
3. Вызываем `console.log()`, теперь в стеке 3 функции.
4. Как только `console.log()` выполнится, она уйдёт из стека, там останется 2 функции.
5. Выполнившись, функция `inner` тоже уйдёт из стека, в нём останется лишь одна `outer`.
6. `outer()` завершилась - стек пуст.

В синхронном коде в стеке хранится вся цепочка вызовов.

Теперь рассмотрим сценарий с асинхронным кодом:

```jsx
function main() {
  setTimeout(function greet() {
    console.log("Привет!");
  }, 2000);

  console.log("Пока!");
}

main();
```

1. Вызываем функцию `main()`.
2. Вызываем `setTimeout()`. `setTimeout` завершился, он выходит из стека.
3. Вызываем `console.log('Пока!')`, eго вызов завершён, он выходит из стека.
4. Вызов `main` тоже завершён, стек становится пуст.
5. Проходит около 2 секунд, вызывается функция `greet`, она попадает в стек.
6. Она вызывает `console.log('Привет!')` и уходит из стека.
7. После выполнения всего блока, стек снова становится пустым.

Первое, что бросается в глаза — `setTimeout()` завершается сразу, хотя колбэк внутри него ещё не отработал, более того, он даже ещё не был вызван! Здесь нам понадобится ещё одно понятие — **цикл событий**.

[Следующий урок](../event-loop/)
